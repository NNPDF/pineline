# From 0 to a fit: implementation of vrap as part of the _pineline_

Problem outline:
We want to isolate and study the effect of a NNLO contribution for a particular process in a fit.
We will use Fixed-Target Drell-Yan in a NNPDF4.0-like fit.
We start by selecting an appropriate Monte Carlo generator which will be used to compute the partonic cross section.
The generator is then interfaced with `pinefarm` to generate `pineappl` grids.
Once grids are obtained we can generate evolution kernel operators (EKOs) to transform them into FKTables
so that they can be used as part of a fit.

## Grid generation
Since our goal is to study the impact of the NNLO contribution to a particular cross-section,
it is necessary to choose a parton-level fixed-order generator.
For this exercise we have choosen [`vrap`](https://www.slac.stanford.edu/~lance/Vrap/)[^1]
which is able to compute Drell-Yan at NNLO with fixed-target kinematics.

In order to be able to produce grids with it, we have modified the original `vrap`
to also output `pineappl` grids after the calculation of a cross-section.
We have dubbed this "vrap with pineappl" with the tongue-in-cheek name of [Hawaiian Vrap](https://github.com/NNPDF/hawaiian_vrap).

> **_NOTE:_** An example of usage for `hawaiian vrap` can be found [here](https://github.com/NNPDF/hawaiian_vrap/tree/main/NNPDFCards)

### 1. Prepare a developer installation of `pinefarm`
The `hawaiian vrap` interface in `pinefarm` is [already available](https://github.com/NNPDF/pinefarm/blob/main/src/pinefarm/external/vrap.py).
In this section we will go through the essential aspects of implementing a new program in `pinefarm`.

For that we need to clone the `pinefarm` repository and install it in developer mode.
`pinefarm`, which glues together other pieces of code, is a python code and we use [poetry](https://python-poetry.org) for package management and development.

```bash
git clone https://github.com/NNPDF/pinefarm.git
cd pinefarm
poetry shell
pip install -e .
```

### 2. Add an automatic installer
Since `pinefarm` builds up an environment with all the necessary packages, the first step is to add an installer to the `install.py` [file](https://github.com/NNPDF/pinefarm/blob/b6993605ef3ab6b5fa711f384d8fdcbf2108c8a7/src/pinefarm/install.py#L85).

The code below performs a couple of check and then installs `hawaiian vrap`.

```python
def hawaiian_vrap():
    # Ensure that pineappl and lhapdf are installed
    _ = lhapdf()
    _ = pineappl(capi=True)

    # Use the configs module to have a generic vrap executable path
    vrapx = configs.configs["commands"]["vrap"]

    # Have a rule to check whether vrap is installed as we want
    if is_exe(vrapx):
        print("✓ Found vrap")
        return True

    # Download and instal the desired version of vrap
    url = f"https://github.com/NNPDF/hawaiian_vrap/archive/refs/tags/1.4.tar.gz"
    print(f"Installing the version {vrap.VERSION} of vrap from {url}")

    # Uncompress the downloaded vrap and install it in the prefix path set by config
    with tempfile.TemporaryDirectory() as tmp:
        tmp_path = pathlib.Path(tmp)
        vrap_tar = tmp_path / f"hawaiian_vrap-{vrap.VERSION}.tar.gz"
        with requests.get(url) as r:
            vrap_tar.write_bytes(r.content)

        with tarfile.open(vrap_tar, "r:gz") as tar:
            tar.extractall(tmp_path)

        # Compile vrap
        tmp_vrap = tmp_path / f"hawaiian_vrap-{vrap.VERSION}"
        subprocess.run("autoreconf -fiv", cwd=tmp_vrap / "src", shell=True, check=True)
        build_dir = tmp_vrap / "build"
        build_dir.mkdir(exist_ok=True)
        subprocess.run(
            ["../src/configure", "--prefix", configs.configs["paths"]["prefix"]],
            cwd=build_dir,
            check=True,
        )
        subprocess.run(["make", "install"], cwd=build_dir, check=True)

    return is_exe(vrapx)
```

Once the installation is prepared, add a command line option to install it by copying one of the options [here](https://github.com/NNPDF/pinefarm/blob/b6993605ef3ab6b5fa711f384d8fdcbf2108c8a7/src/pinefarm/cli/install.py#L29).

Then inside the `poetry shell` we can do:
```bash
pinefarm install vrap
```

### 3. Write a runner for `hawaiian vrap`
There are several runners already available in the `pinefarm` for various degrees of complexity in the [external folder](https://github.com/NNPDF/pinefarm/tree/main/src/pinefarm/external).
The runner for `hawaiian vrap`, since it has to deal with a relatively simple format of runcard and only one type of process is not very complicated so we can go through it step by step.

#### 1. Initializer of the runner
We write a subclass of `pinefarm.external.interface.External`. Every run of `pinefarm` for a particular program start by instantiating this class and taking a `pinecard` defining the run (see examples [here](https://github.com/NNPDF/pinecards/) and a [theory card](https://github.com/NNPDF/pinefarm/blob/main/extras/theories/theory_200_1.yaml).

The instantiation of the class should read both and construct the right runcard for the target program.
In the case of `hawaiian vrap` this is straightforward since the runcard follows a very similar format.
For instance, [here](https://github.com/NNPDF/hawaiian_vrap/blob/main/NNPDFCards/DYE605.dat) we have a runcard for `hawaiian vrap` to be compared with the associated [pinecard](https://github.com/NNPDF/pinecards/blob/master/DYE605/vrap.yaml), which is just a `yaml` version of the same information.

In general we should read all information form the theory runcard and fill in the necessary parameters in the runcard of the generator.

In this tutorial we are simply going to read the perturbative order `PTO` and translate it to the notation that `vrap` uses (`LO`, `NLO`, `NNLO`).
Then we read the list of kinematics we are interested in (simply two columns with Q and rapidity) [example](https://github.com/NNPDF/pinecards/blob/master/DYE605/DYE605.dat).

Although the grid is PDF independent, the generator (usually) require a PDF to run.
This is given by the `pdf` attribute: `self.pdf`.

```python
class Vrap(External):
    def __init__(self, pinecard, theorycard, *args, **kwargs):
        super().__init__(pinecard, theorycard, *args, **kwargs)

        # Read and translate perturbative order
        order = theorycard.get("PTO")
        if order == 0:
            vrap_order = "LO"
        elif order == 1:
            vrap_order = "NLO"
        elif order >= 2:
            vrap_order = "NNLO"
        else:
            raise ValueError(f"Order PTO={order} not understood by vrap runner")

        # It will be DYE605.dat if the name of the pinecard is DYE605
        self._kin_card = f"{self.name}*.dat")

        # Read the input card
        input_card = self.source / "vrap.yaml"
        yaml_dict = yaml.safe_load(input_card.open("r", encoding="utf-8"))
        yaml_dict["Order"] = vrap_order
        input_yaml["PDFfile"] = f"{self.pdf}.LHgrid"

        # Write down the vrap runcard
        self._input_card = (self.dest / self.name).with_suffix(".dat")
        as_lines = [f"{k} {v}" for k, v in yaml_dict.items()]
        self._input_card.write_text("\n".join(as_lines))

    def collect_versions(self):
        """Currently the version is defined by this file"""
        return {"vrap_version": "1.4"}
```

#### 2. The `run` method
Once the translation layer (through the instantiation of the class) is generated, the next step is to define how the code will be `run` with the `run` method of the class.
We use [`subprocess.run`](https://docs.python.org/3/library/subprocess.html#subprocess.run) to run the command.
The output folder is auto-filled by `pinefarm` as the `dest` property which we use to run the command (`cwd=self.dest`).
The `pineappl` result of `hawaiian vrap` is called `test.pineappl.lz4` so at the end we modify it to the desired name (in our case just the name of the dataset, also filled by `pinefarm`: `self.grid`).

```python
    def run(self):
        command = configs.configs["commands"]["vrap"]
        subprocess.run([command, self._input_card, self._kin_card], cwd=self.dest, check=True)

        pineappl_file = self.dest / "test.pineappl.lz4"

        # Optimize the grid 
        grid = pineappl.grid.Grid.read(pineappl_file.as_posix())
        grid.optimize()
        grid.write(self.grid)

        # Read up also the MC results for later comparison
        _, _, cv, stat = np.loadtxt(self.dest / "results.out", unpack=True)
        self._results = (cv, stat)
```

#### 4. Checking the results
At the end of every run, `pinefarm` will try to check that the results from the `pineappl` grid are compatible with the results obtained during the integration.
The class is required to fill a `pandas.DataFrame` with `result`, `error`, `sv_min` and `sv_max` using the `results` method. 
The `sv_` variables are for scale variations if the Monte Carlo generator provides numbers for a check.

```python
    def results(self):
        cv, stat_errors = self._results
        final_cv = np.sum(cv, axis=0)
        final_stat = np.sqrt(np.sum(np.power(stat_errors, 2), axis=0))

        d = {
            "result": final_cv,
            "error": final_stat,
            "sv_min": np.zeros_like(final_cv),
            "sv_max": np.zeros_like(final_cv),
        }

        return pd.DataFrame(data=d)
```

### 5. Run!

After the runner is prepared, we can now run `vrap` for any dataset by preparing the run information in the appropriate format.
There are many examples in the public [`pinecards` repository](https://github.com/NNPDF/pinecards).

Every folder in the repository is a separate ``pinecard``.
Since different programs take different inputs, the content of the folder might change from program to program.

In the generic `metadata.txt` file we include any relevant information about the observable:
```txt
description='E605 Fixed-Target Drell-Yan cross section measurement with nuclear copper target'
hepdata=10.17182/hepdata.22831/t1-t8
data_url=
nnpdf_id=DYE605
fktable_id=DYE605
x1_label=sqrt(tau)
x1_label_tex=$\sqrt(\tau)$
x1_unit=
x2_label=y
x2_label_tex=$y$
x2_unit=
y_label_tex = $s*\frac{d^2\sigma}{d\sqrt(\tau)dy}$
y_label=s*d^2sigma/dsqrt(tau)/dy
y_unit=pb GeV^2
```

Then the information necessary to run the program is given as a human (and computer) readable `.yaml` file.

```yaml
Collider: piso
E_CM: 38.8
Alphat: 0.00757002271
Q: 0
VectorBoson: Zgamma
muFoverQ: 1.0
muRoverQ: 1.0
Nf: 5
UseOtherPDF: "yes"
PDFset: 0
AlphasZ: 0.118
Order: NLO
PrintDirection: Forward
NNLO_only: "no"
RandomSeed: 22334
```

Note that some of the information on this file, such as `Order` will be rewritten by the translation layer that we have prepared in the previous steps.
Although in this example we have limited ourselves to the order of the calculation, in principle all theory-related information should be appropriately modified by the translation layer.

Finally, in the case of `hawaiian vrap` the kinematics are provided as a separate `.dat` file containing the values of Q and rapidity for the desired points.
```
7.10428  -0.2
7.30604  -0.2
7.5078  -0.2
```

Now we are ready to run:
```bash
pinefarm run pinecards/DYE605 theories/theory_200_1.yaml
````
the results will be output to the `results/DYE605-<timestamp>` folder.

## Evolution kernel operators and FKTables
We have made available detailed guides for the [set-up](../tutorials/setup) and [generation of FK Tables](../tutorials/fktable) using `pineko`.
Here we outline the most relevant steps.

```bash
```

## Usage within NNPDF

Once we have the new FKTable prepared `DYE605.pineappl.lz4`, it is time to run a fit!
For this we will use the NNPDF fitting framework.

> **_NOTE:_** If you need to install NNPDF please follow the [installation guide](https://docs.nnpdf.science/get-started/installation.html) and the [how to run a fit](https://docs.nnpdf.science/tutorials/run-fit.html) tutorial.

In order to use our new FKTables for DYE605, we are going to modify one of the [theories](https://docs.nnpdf.science/theory/theoryindex.html) already available within NNPDF.
We are going to use Theory 400 which includes NNLO grids for all DIS observables and NLO grids (with k-factors for the NNLO contribution) for hadronic observables.

```bash
~$ vp-get theoryID 400
...
TheoryIDSpec(id=400, path=PosixPath('/path/to/prefix/share/NNPDF/data/theory_400'))
````

After downloading the theory, it will be uncompressed to a folder.
Inside this folder we find the `theory_400/fastkernel` subfolder, which contains all FK tables available for the theory.
Among them there is `DYE605.pineappl.lz4`.
We can substitute it with the fktable that we just created... et voilà!

If now we run an NNPDF fit with theory 400 the theory associated to DYE605 will be NNLO.
Do not forget to remove the QCD c-factor from the [fitting runcard](https://github.com/NNPDF/nnpdf/blob/master/n3fit/runcards/reproduce_nnpdf40/NNPDF40_nnlo_as_01180_1000.yml) if it is not needed anymore!


[^1]:
    Phys.Rev.D69:094008,2004 [hep-ph/0312266](https://arxiv.org/abs/hep-ph/0312266)
